# Note

1. 静态成员函数不能在对象中被调用，不能使用this指针，只能访问静态成员变量
2. 静态类成员变量具有一个特点：「无论创建了多少个对象，程序都只创建一个静态类成员变量的副本」。也就是说，【所创建类的所有对象均共享同一个静态类成员变量】。
   1. 在初始化语句中，指出了类静态成员变量的类型「int」，并使用了类作用域解析运算符「::」，但并没有使用关键字「static」。
   2. 类静态成员变量的初始化是在方法实现文件中进行的，而不是在类声明文件中进行。这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。
   3. 类中只是描述了如何分配内存，没有真正分配内存，所以必须在类外进行初始化。
   4. 当静态成员变量为「const」整数类型或枚举类型时，可以在类声明中初始化。
3. 内联函数
   1. inline 的使用是有所限制的，inline 只适合涵数体内代码简单的涵数使用，不能包含复杂的结构控制语句例如 while、switch，并且不能内联函数本身不能是直接递归函数（即，自己内部还调用自己的函数）。
   2. inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已。
   3. 将内联函数的定义放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。
   4. 定义在类中的成员函数默认都是内联的
   5. 关键字 inline 必须与函数定义体放在一起才能使函数成为内联
   6. inline 函数仅仅是一个对编译器的建议，所以最后能否真正内联，看编译器的意思，它如果认为函数不复杂，能在调用点展开，就会真正内联，并不是说声明了内联就会内联，声明内联只是一个建议而已
   7. 不要随便地将构造函数和析构函数的定义体放在类声明中
4. #define HZ_CORE_ERROR(...) ::Hazel::Log::GetCoreLogger()->error(__VA_ARGS__)表示在全局空间中查找宏
5. cmake、premake配置文件的好处：不用每次都手动配置IDE设置或者makefile文件，可以自动生成ide的工程文件或者makefile文件